<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ObitUVPeelUtil.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">include</a></div>
<h1>ObitUVPeelUtil.h File Reference</h1>ObitUVPeelUtil module definition. <a href="#_details">More...</a>
<p>
<code>#include "<a class="el" href="ObitInfoList_8h-source.html">ObitInfoList.h</a>"</code><br>
<code>#include "<a class="el" href="ObitUV_8h-source.html">ObitUV.h</a>"</code><br>
<code>#include "<a class="el" href="ObitDConCleanVis_8h-source.html">ObitDConCleanVis.h</a>"</code><br>
<code>#include "<a class="el" href="ObitErr_8h-source.html">ObitErr.h</a>"</code><br>

<p>
<a href="ObitUVPeelUtil_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ObitTypes_8h.html#a5">olong</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ObitUVPeelUtil_8h.html#a0">ObitUVPeelUtilPeel</a> (<a class="el" href="structObitInfoList.html">ObitInfoList</a> *myInput, <a class="el" href="structObitUV.html">ObitUV</a> *inUV, <a class="el" href="structObitDConCleanVis.html">ObitDConCleanVis</a> *myClean, <a class="el" href="structObitErr.html">ObitErr</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Public: Peel strong source from UV data based on previous CLEAN.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ObitUVPeelUtil_8h.html#a1">ObitUVPeelUtilLoop</a> (<a class="el" href="structObitInfoList.html">ObitInfoList</a> *myInput, <a class="el" href="structObitUV.html">ObitUV</a> *inUV, <a class="el" href="structObitDConCleanVis.html">ObitDConCleanVis</a> *myClean, <a class="el" href="ObitTypes_8h.html#a5">olong</a> *nfield, <a class="el" href="ObitTypes_8h.html#a5">olong</a> **ncomp, <a class="el" href="structObitErr.html">ObitErr</a> *err)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Public: Loop over sources to be peeled.  <a href="#a1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
ObitUVPeelUtil module definition. 
<p>
This utility utility contains utility functions for "peeling" uv data. This technique is to subtract individual sources after self calibrating on them.<hr><h2>Function Documentation</h2>
<a class="anchor" name="a1" doxytag="ObitUVPeelUtil.h::ObitUVPeelUtilLoop"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ObitUVPeelUtilLoop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structObitInfoList.html">ObitInfoList</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>myInput</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structObitUV.html">ObitUV</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>inUV</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structObitDConCleanVis.html">ObitDConCleanVis</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>myClean</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="ObitTypes_8h.html#a5">olong</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>nfield</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="ObitTypes_8h.html#a5">olong</a> **&nbsp;</td>
          <td class="mdname" nowrap> <em>ncomp</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structObitErr.html">ObitErr</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>err</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Public: Loop over sources to be peeled. 
<p>
This routine should only be run after all self-calibration and autocentering has been done, at least one previous CLEAN is required. Each loop picks the strongest field with peak above PeelFlux and subtracts all others using the SkyModel on myClean and then self-calibrates the residual data to obtain a best model and calibration for that field. A model uv data set derived from the self-calibrated model and inverse of the self cal calibration is used to corrupt the model data which is then permanently subtracted from the input data. The imaging is then redone using the myClean setup. The components peeled are written to CC Table 2 on the output peeled image. After all peeling is done, the components on the CC tables 2 are appended to CC tables 1 so that these tables contain all components subtracted. On return, ncomp contains the number of components in each CC table 1 which were NOT peeled, i.e. should be subtracted from inUV to produce a residual data set. No component restoration or flattening is done. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>myInput</em>&nbsp;</td><td>InfoList with control parameters (most have defaults): <ul>
<li>PeelFlux f Minimum level for Peeling (peal in CCs) </li>
<li>PeelLoop i max. number of self cal loops </li>
<li>PeelSolInt f Peel SC Solution interval (min) </li>
<li>PeelType s Peel SC Solution type ' ', 'L1' </li>
<li>PeelMode s Peel SC Solution mode:'A&amp;P', 'P', 'P!A', </li>
<li>PeelNiter i Niter for peel.CLEAN </li>
<li>PeelMinFlux f Minimum Peel Clean component (Jy) </li>
<li>PeelRefAnt i Peel SC Reference antenna </li>
<li>PeelSNRMin f Min. allowed SNR in peel selfcal </li>
<li>PeelAvgPol b Avg. poln in peel self cal? </li>
<li>PeelAvgIF b Avg. IFs in peel self cal? </li>
<li>PBCor b Apply Frequency PB Corr? </li>
<li>antSize f Diameter of ant. for PBCor (m) </li>
<li>Robust f Robustness power </li>
<li>nuGrid i Size in u of weighting grid </li>
<li>nvGrid i Size in v of weighting grid </li>
<li>WtBox i Additional rows and columns in weighting </li>
<li>WtFunc i Box function type when WtBox </li>
<li>UVTaper f [2] (U,V) Gaussian taper klambda </li>
<li>WtPower f Power to raise weights to </li>
<li>MaxBaseline f maximum baseline length in wavelengths. </li>
<li>MinBaseline f minimum baseline length in wavelengths. </li>
<li>rotate f rotation of images </li>
<li>xCells f Image cell spacing in X in asec. </li>
<li>yCells f Image cell spacing in Y in asec. </li>
<li>Gain f CLEAN loop gain </li>
<li>minPatch i Min. BEAM half-width. </li>
<li>autoWindow b If true, automatically set windows </li>
<li>WtUV f Weighting to use outside of basic uv range </li>
<li>minNo i Min. allowed no. antennas in selfcal </li>
<li>doSmoo b If true interpolate failed solutions </li>
<li>prtLv i Print level in selfcal, 0=&gt;none </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inUV</em>&nbsp;</td><td>Data to be peeled, on return all SN tables will be removed. and peeled source will have been subtracted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>myClean</em>&nbsp;</td><td>Clean object which has previously been CLEANed and which has a field with a CC peak in excess of PeelFlux. Need for peeling based on values of myClean-&gt;peakFlux and PeelFlux. The test for individual fields is the maximum as determined from the CLEAN components by <a class="el" href="ObitImageMosaic_8c.html#a30">ObitImageMosaicMaxField</a> On output, this will include info on last CLEAN </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nfield</em>&nbsp;</td><td>[out] Number of entries in ncomp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ncomp</em>&nbsp;</td><td>[out] Array of number of components in data (i.e. after any peel) per field, this array should be g_freeed after use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Error/message stack </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="ObitUVPeelUtil.h::ObitUVPeelUtilPeel"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="ObitTypes_8h.html#a5">olong</a> ObitUVPeelUtilPeel           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structObitInfoList.html">ObitInfoList</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>myInput</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structObitUV.html">ObitUV</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>inUV</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structObitDConCleanVis.html">ObitDConCleanVis</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>myClean</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="structObitErr.html">ObitErr</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>err</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Public: Peel strong source from UV data based on previous CLEAN. 
<p>
Picks the strongest field with peak above PeelFlux and subtracts all others using the SkyModel on myClean and then self calibrates the residual data to obtain a best model and calibration for that field. A model uv data set derived from the selfcalibrated model and inverse of the self cal calibration is used to corrupt the model data which is then subtracted from the input data. The imaging is then redone using the myClean setup . The components peeled are written to CC Table 2 on the output Peeled image. Note: If multiple peels are done, the components from previously peeled fields will not be in Table 1 and the components from any CC table 2 need to be copied to table 1 when the peeling is finished. No restoration or flattening is done. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>myInput</em>&nbsp;</td><td>InfoList with control parameters (most have defaults): <ul>
<li>PeelFlux f Minimum level for Peeling (peal in CCs) </li>
<li>PeelLoop i max. number of self cal loops </li>
<li>PeelSolInt f Peel SC Solution interval (min) </li>
<li>PeelType s Peel SC Solution type ' ', 'L1' </li>
<li>PeelMode s Peel SC Solution mode:'A&amp;P', 'P', 'P!A', </li>
<li>PeelNiter i Niter for peel.CLEAN </li>
<li>PeelMinFlux f Minimum Peel Clean component (Jy) </li>
<li>PeelRefAnt i Peel SC Reference antenna </li>
<li>PeelSNRMin f Min. allowed SNR in peel selfcal </li>
<li>PeelAvgPol b Avg. poln in peel self cal? </li>
<li>PeelAvgIF b Avg. IFs in peel self cal? </li>
<li>PBCor b Apply Frequency PB Corr? </li>
<li>antSize f Diameter of ant. for PBCor (m) </li>
<li>Robust f Robustness power </li>
<li>nuGrid i Size in u of weighting grid </li>
<li>nvGrid i Size in v of weighting grid </li>
<li>WtBox i Additional rows and columns in weighting </li>
<li>WtFunc i Box function type when WtBox </li>
<li>UVTaper f [2] (U,V) Gaussian taper klambda </li>
<li>WtPower f Power to raise weights to </li>
<li>MaxBaseline f maximum baseline length in wavelengths. </li>
<li>MinBaseline f minimum baseline length in wavelengths. </li>
<li>rotate f rotation of images </li>
<li>xCells f Image cell spacing in X in asec. </li>
<li>yCells f Image cell spacing in Y in asec. </li>
<li>Gain f CLEAN loop gain </li>
<li>minPatch i Min. BEAM half-width. </li>
<li>autoWindow b If true, automatically set windows </li>
<li>WtUV f Weighting to use outside of basic uv range </li>
<li>minNo i Min. allowed no. antennas in selfcal </li>
<li>doSmoo b If true interpolate failed solutions </li>
<li>prtLv i Print level in selfcal, 0=&gt;none </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inUV</em>&nbsp;</td><td>Data to be peeled, on return all SN tables will be removed. and peeled source will have been subtracted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>myClean</em>&nbsp;</td><td>Clean object which has previously been CLEANed and which has a field with a CC peak in excess of PeelFlux. Need for peeling based on values of myClean-&gt;peakFlux and PeelFlux. The test for individual fields is the maximum as determined from the CLEAN components by <a class="el" href="ObitImageMosaic_8c.html#a30">ObitImageMosaicMaxField</a> On output, this will include info on last CLEAN </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>Error/message stack </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the 1-rel field number of the peeled field or -1 if no peel </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Mon Jul 20 08:52:42 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
