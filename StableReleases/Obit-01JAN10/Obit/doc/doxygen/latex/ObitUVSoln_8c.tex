\section{Obit\-UVSoln.c File Reference}
\label{ObitUVSoln_8c}\index{ObitUVSoln.c@{ObitUVSoln.c}}
{\bf Obit\-UVSoln}{\rm (p.\,\pageref{structObitUVSoln})} class function definitions. 

{\tt \#include \char`\"{}Obit\-UVSoln.h\char`\"{}}\par
{\tt \#include \char`\"{}Obit\-Table\-Util.h\char`\"{}}\par
{\tt \#include \char`\"{}Obit\-Table\-SUUtil.h\char`\"{}}\par
\subsection*{Functions}
\begin{CompactItemize}
\item 
void {\bf Obit\-UVSoln\-Init} (gpointer in)
\begin{CompactList}\small\item\em Private: Initialize newly instantiated object. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Clear} (gpointer in)
\begin{CompactList}\small\item\em Private: Deallocate members. \item\end{CompactList}\item 
void {\bf smo\-Amp\-Ph} ({\bf Obit\-Table\-SN} $\ast$SNTab, {\bf Obit\-UVSel} $\ast$sel, gchar $\ast$smo\-Func, gchar $\ast$smo\-Type, {\bf ofloat} alpha, {\bf ofloat} $\ast$smo\-Parm, {\bf olong} sub, {\bf olong} ifbeg, {\bf olong} ifend, {\bf odouble} $\ast$freqs, gboolean do\-Blank, {\bf ofloat} $\ast$gncnt, {\bf ofloat} $\ast$gnsum, {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Coherent amplitude/phase smoothing. \item\end{CompactList}\item 
void {\bf smo\-It} (gchar $\ast$smmeth, {\bf ofloat} width, {\bf ofloat} alpha, {\bf ofloat} $\ast$x, {\bf ofloat} $\ast$t, {\bf ofloat} $\ast$w, {\bf olong} n, {\bf ofloat} $\ast$xs, {\bf ofloat} $\ast$ws, {\bf ofloat} $\ast$wrk1, {\bf ofloat} $\ast$wrk2, gboolean do\-Blank)
\begin{CompactList}\small\item\em Private: Generic smoothing. \item\end{CompactList}\item 
{\bf Obit\-UVSoln} $\ast$ {\bf new\-Obit\-UVSoln} (gchar $\ast$name)
\begin{CompactList}\small\item\em Public: Default Constructor. \item\end{CompactList}\item 
gconstpointer {\bf Obit\-UVSoln\-Get\-Class} (void)
\begin{CompactList}\small\item\em Public: Class\-Info pointer. \item\end{CompactList}\item 
{\bf Obit\-UVSoln} $\ast$ {\bf Obit\-UVSoln\-Create} (gchar $\ast$name, {\bf Obit\-UV} $\ast$in\-UV)
\begin{CompactList}\small\item\em Public: Create/initialize {\bf Obit\-UVSoln}{\rm (p.\,\pageref{structObitUVSoln})} structures. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Start\-Up} ({\bf Obit\-UVSoln} $\ast$in, {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Public: Initialize interpolation. \item\end{CompactList}\item 
gboolean {\bf Obit\-UVSoln\-Get\-SN} ({\bf Obit\-UVSoln} $\ast$in, {\bf Obit\-Table\-SNRow} $\ast$SNrow, {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Public: interpolate calibration at a given time. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Shut\-Down} ({\bf Obit\-UVSoln} $\ast$in, {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Public: Shutdown interpolation. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Ref\-Ant} ({\bf Obit\-Table\-SN} $\ast$SNTab, {\bf olong} isuba, {\bf olong} $\ast$refant, {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Refererence phases to a common reference antenna. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Avg\-Rate} ({\bf Obit\-Table\-SN} $\ast$SNTab, {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Average fringe rates over IF/poln in an SN table. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-SNSmo} ({\bf Obit\-Table\-SN} $\ast$SNTab, {\bf olong} isuba, {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Smooth an SN table and possible interpolate blanked soln. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Desel\-SN} ({\bf Obit\-Table\-SN} $\ast$SNTab, {\bf olong} isuba, {\bf olong} fqid, {\bf olong} nantf, {\bf olong} $\ast$ants, {\bf olong} nsou, {\bf olong} $\ast$sources, {\bf ofloat} timerange[2], {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Deselect records in an SN table. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Desel\-CL} ({\bf Obit\-Table\-CL} $\ast$CLTab, {\bf olong} isuba, {\bf olong} fqid, {\bf olong} nantf, {\bf olong} $\ast$ants, {\bf olong} nsou, {\bf olong} $\ast$sources, {\bf ofloat} timerange[2], {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Deselect records in a CL table. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-SNSmooth} ({\bf Obit\-Table\-SN} $\ast$SNTab, gchar $\ast$smo\-Func, gchar $\ast$smo\-Type, {\bf ofloat} alpha, {\bf ofloat} $\ast$smo\-Parm, {\bf olong} iif, {\bf olong} sub, {\bf ofloat} $\ast$gncnt, {\bf ofloat} $\ast$gnsum, {\bf olong} nxt, {\bf ofloat} $\ast$work1, {\bf ofloat} $\ast$work2, gboolean do\-Blank, {\bf Obit\-Err} $\ast$err)
\begin{CompactList}\small\item\em Smooth solutions for a given IF and subarray. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Smoo\-Box} ({\bf ofloat} width, {\bf ofloat} $\ast$x, {\bf ofloat} $\ast$y, {\bf ofloat} $\ast$w, {\bf olong} n, {\bf ofloat} $\ast$ys, {\bf ofloat} $\ast$ws, gboolean do\-Blank)
\begin{CompactList}\small\item\em Boxcar smoothing with weighting of an irregularly spaced array. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Smoo\-Gauss} ({\bf ofloat} width, {\bf ofloat} $\ast$x, {\bf ofloat} $\ast$y, {\bf ofloat} $\ast$w, {\bf olong} n, {\bf ofloat} $\ast$ys, {\bf ofloat} $\ast$ws, {\bf ofloat} $\ast$wtsum, gboolean do\-Blank)
\begin{CompactList}\small\item\em Gaussian smoothing with weighting of an irregularly spaced array. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Smoo\-MWF} ({\bf ofloat} width, {\bf ofloat} alpha, {\bf ofloat} $\ast$x, {\bf ofloat} $\ast$y, {\bf ofloat} $\ast$w, {\bf olong} n, {\bf ofloat} $\ast$ys, {\bf ofloat} $\ast$ws, {\bf ofloat} $\ast$yor, {\bf ofloat} $\ast$wor, gboolean do\-Blank)
\begin{CompactList}\small\item\em Median Window smoothing with weighting of an irregularly spaced array. \item\end{CompactList}\item 
void {\bf Obit\-UVSoln\-Class\-Init} (void)
\begin{CompactList}\small\item\em Public: Class initializer. \item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
{\bf Obit\-UVSoln}{\rm (p.\,\pageref{structObitUVSoln})} class function definitions. 

This clas allows manipulation (interpolation) of Solutions in an {\bf Obit\-Table\-SN}{\rm (p.\,\pageref{structObitTableSN})}. This class is derived from the {\bf Obit}{\rm (p.\,\pageref{structObit})} base class.

\subsection{Function Documentation}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!newObitUVSoln@{newObitUVSoln}}
\index{newObitUVSoln@{newObitUVSoln}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Obit\-UVSoln}$\ast$ new\-Obit\-UVSoln (gchar $\ast$ {\em name})}\label{ObitUVSoln_8c_a20}


Public: Default Constructor. 

Initializes class if needed on first call. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em name}]An optional name for the object. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]the new object. \end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnAvgRate@{ObitUVSolnAvgRate}}
\index{ObitUVSolnAvgRate@{ObitUVSolnAvgRate}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Avg\-Rate ({\bf Obit\-Table\-SN} $\ast$ {\em SNTab}, {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a27}


Average fringe rates over IF/poln in an SN table. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em SNTab}]SN table object \item[{\em err}]Error/message stack, returns if error. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnClassInit@{ObitUVSolnClassInit}}
\index{ObitUVSolnClassInit@{ObitUVSolnClassInit}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Class\-Init (void)}\label{ObitUVSoln_8c_a35}


Public: Class initializer. 

\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnClear@{ObitUVSolnClear}}
\index{ObitUVSolnClear@{ObitUVSolnClear}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Clear (gpointer {\em inn})}\label{ObitUVSoln_8c_a4}


Private: Deallocate members. 

Does (recursive) deallocation of parent class members. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em inn}]Pointer to the object to deallocate. Actually it should be an Obit\-UVSoln$\ast$ cast to an Obit$\ast$. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnCreate@{ObitUVSolnCreate}}
\index{ObitUVSolnCreate@{ObitUVSolnCreate}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf Obit\-UVSoln}$\ast$ Obit\-UVSoln\-Create (gchar $\ast$ {\em name}, {\bf Obit\-UV} $\ast$ {\em in\-UV})}\label{ObitUVSoln_8c_a22}


Public: Create/initialize {\bf Obit\-UVSoln}{\rm (p.\,\pageref{structObitUVSoln})} structures. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em name}]An optional name for the object. \item[{\em in\-UV}]UV data with input SN table \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]the new object. \end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnDeselCL@{ObitUVSolnDeselCL}}
\index{ObitUVSolnDeselCL@{ObitUVSolnDeselCL}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Desel\-CL ({\bf Obit\-Table\-CL} $\ast$ {\em CLTab}, {\bf olong} {\em isuba}, {\bf olong} {\em fqid}, {\bf olong} {\em nantf}, {\bf olong} $\ast$ {\em ants}, {\bf olong} {\em nsou}, {\bf olong} $\ast$ {\em sources}, {\bf ofloat} {\em timerange}[2], {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a30}


Deselect records in a CL table. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em CLTab}]CL table object \item[{\em isub}]Subarray number, $<$=0 -$>$ any \item[{\em fqid}]Selected FQ id, $<$=0 -$>$ any \item[{\em nantf}]Number of antennas in ants \item[{\em ants}]List of antennas, NULL or 0 in first -$>$ flag all \item[{\em nsou}]Number of source ids in sources \item[{\em sources}]List of sources, NULL or 0 in first -$>$ flag all \item[{\em timerange}]Timerange to flag, 0s -$>$ all \item[{\em err}]Error/message stack, returns if error. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnDeselSN@{ObitUVSolnDeselSN}}
\index{ObitUVSolnDeselSN@{ObitUVSolnDeselSN}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Desel\-SN ({\bf Obit\-Table\-SN} $\ast$ {\em SNTab}, {\bf olong} {\em isuba}, {\bf olong} {\em fqid}, {\bf olong} {\em nantf}, {\bf olong} $\ast$ {\em ants}, {\bf olong} {\em nsou}, {\bf olong} $\ast$ {\em sources}, {\bf ofloat} {\em timerange}[2], {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a29}


Deselect records in an SN table. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em SNTab}]SN table object \item[{\em isub}]Subarray number, $<$=0 -$>$ any \item[{\em fqid}]Selected FQ id, $<$=0 -$>$ any \item[{\em nantf}]Number of antennas in ants \item[{\em ants}]List of antennas, NULL or 0 in first -$>$ flag all \item[{\em nsou}]Number of source ids in sources \item[{\em sources}]List of sources, NULL or 0 in first -$>$ flag all \item[{\em timerange}]Timerange to flag, 0s -$>$ all \item[{\em err}]Error/message stack, returns if error. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnGetClass@{ObitUVSolnGetClass}}
\index{ObitUVSolnGetClass@{ObitUVSolnGetClass}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}gconstpointer Obit\-UVSoln\-Get\-Class (void)}\label{ObitUVSoln_8c_a21}


Public: Class\-Info pointer. 

\begin{Desc}
\item[Returns:]pointer to the class structure. \end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnGetSN@{ObitUVSolnGetSN}}
\index{ObitUVSolnGetSN@{ObitUVSolnGetSN}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}gboolean Obit\-UVSoln\-Get\-SN ({\bf Obit\-UVSoln} $\ast$ {\em in}, {\bf Obit\-Table\-SNRow} $\ast$ {\em SNrow}, {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a24}


Public: interpolate calibration at a given time. 

Input values on an {\bf Obit\-Table\-SNRow}{\rm (p.\,\pageref{structObitTableSNRow})} into which the results are added. Data selection is enabled. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em in}]Solution Object. \item[{\em SNRow}]SN row giving desired time, antenna..., and to receive output \item[{\em err}]Obit\-Error stack. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]TRUE if source, time etc. selected, else FALSE. \end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnInit@{ObitUVSolnInit}}
\index{ObitUVSolnInit@{ObitUVSolnInit}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Init (gpointer {\em inn})}\label{ObitUVSoln_8c_a3}


Private: Initialize newly instantiated object. 

Parent classes portions are (recursively) initialized first \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em inn}]Pointer to the object to initialize. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnRefAnt@{ObitUVSolnRefAnt}}
\index{ObitUVSolnRefAnt@{ObitUVSolnRefAnt}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Ref\-Ant ({\bf Obit\-Table\-SN} $\ast$ {\em SNTab}, {\bf olong} {\em isuba}, {\bf olong} $\ast$ {\em refant}, {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a26}


Refererence phases to a common reference antenna. 

Leaves the output table sorted in antenna-time order. Routine translated from the AIPSish UVUTIL.FOR/SLFREF \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em SNTab}]SN table object \item[{\em isuba}]Desired subarray, 0=$>$ 1 \item[{\em refant}]Reference antenna, if 0 then the most commonly used reference antenna is picked. If $<$0 then only sort and not reference table \item[{\em err}]Error/message stack, returns if error. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnShutDown@{ObitUVSolnShutDown}}
\index{ObitUVSolnShutDown@{ObitUVSolnShutDown}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Shut\-Down ({\bf Obit\-UVSoln} $\ast$ {\em in}, {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a25}


Public: Shutdown interpolation. 

Close any open file and destroy structures. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em in}]Calibrate Object. \item[{\em err}]Obit\-Error stack. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnSmooBox@{ObitUVSolnSmooBox}}
\index{ObitUVSolnSmooBox@{ObitUVSolnSmooBox}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Smoo\-Box ({\bf ofloat} {\em width}, {\bf ofloat} $\ast$ {\em x}, {\bf ofloat} $\ast$ {\em y}, {\bf ofloat} $\ast$ {\em w}, {\bf olong} {\em n}, {\bf ofloat} $\ast$ {\em ys}, {\bf ofloat} $\ast$ {\em ws}, gboolean {\em do\-Blank})}\label{ObitUVSoln_8c_a32}


Boxcar smoothing with weighting of an irregularly spaced array. 

Only returns blanked values if no valid data found. First good value used for all previous points, last good value used for all subsequent points in which all data are blanked in the boxcar. A datum is blanked if its weight is $<$= 0 or fblank. Routine translated from the AIPSish SMBOX.FOR/SMBOX \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em width}]Width of boxcar in same units as X: 0 =$>$ replace blanks with interpolated closest 2, $<$ 0 =$>$ replace only blanks with the boxcar smoothed values (all others remain unchanged) \item[{\em x}]Abscissas of points to be smoothed in increasing order \item[{\em y}]Values to be smoothed. \item[{\em w}]Weights of data. \item[{\em n}]Number of points to smooth. \item[{\em ys}]Smoothed values. \item[{\em ws}]Smoothed weights \item[{\em do\-Blank}]replace blanked values with interpolated values? \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnSmooGauss@{ObitUVSolnSmooGauss}}
\index{ObitUVSolnSmooGauss@{ObitUVSolnSmooGauss}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Smoo\-Gauss ({\bf ofloat} {\em width}, {\bf ofloat} $\ast$ {\em x}, {\bf ofloat} $\ast$ {\em y}, {\bf ofloat} $\ast$ {\em w}, {\bf olong} {\em n}, {\bf ofloat} $\ast$ {\em ys}, {\bf ofloat} $\ast$ {\em ws}, {\bf ofloat} $\ast$ {\em wtsum}, gboolean {\em do\-Blank})}\label{ObitUVSoln_8c_a33}


Gaussian smoothing with weighting of an irregularly spaced array. 

Only returns blanked values if no valid data found. First good value used for all previous points, last good value used for all subsequent points in which all data are blanked in the smoothing interval. A datum is considered blanked if its weight is $<$= 0 or its value fblank. Routine translated from the AIPSish SMGAUS.FOR/SMGAUS \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em width}]Width of boxcar in same units as X: 0 =$>$ replace blanks with interpolated closest 2, $<$ 0 =$>$ replace only blanks with the b oxcar smoothed values (all others remain unchanged) \item[{\em x}]Abscissas of points to be smoothed in increasing order \item[{\em y}]Values to be smoothed. \item[{\em w}]Weights of data. \item[{\em n}]Number of points to smooth. \item[{\em ys}]Smoothed values. \item[{\em ws}]Smoothed weights \item[{\em wtsum}]scratch \item[{\em do\-Blank}]replace blanked values with interpolated values. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnSmooMWF@{ObitUVSolnSmooMWF}}
\index{ObitUVSolnSmooMWF@{ObitUVSolnSmooMWF}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Smoo\-MWF ({\bf ofloat} {\em width}, {\bf ofloat} {\em alpha}, {\bf ofloat} $\ast$ {\em x}, {\bf ofloat} $\ast$ {\em y}, {\bf ofloat} $\ast$ {\em w}, {\bf olong} {\em n}, {\bf ofloat} $\ast$ {\em ys}, {\bf ofloat} $\ast$ {\em ws}, {\bf ofloat} $\ast$ {\em yor}, {\bf ofloat} $\ast$ {\em wor}, gboolean {\em do\-Blank})}\label{ObitUVSoln_8c_a34}


Median Window smoothing with weighting of an irregularly spaced array. 

Only returns blanked values if no valid data found. First good value used for all previous points, last good value used for all subsequent points in which all data are blanked in the smoothing interval. A datum is considered blanked if its weight is $<$= 0 or its value fblank. Routine translated from the AIPSish SMMWF.FOR/SMMWF \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em width}]Width of boxcar in same units as X: 0 =$>$ replace blanks with interpolated closest 2, $<$ 0 =$>$ replace only blanks with the b oxcar smoothed values (all others remain unchanged) \item[{\em alpha}]0 -$>$ 1 = pure boxcar -$>$ pure MWF (ALPHA of the data samples are discarded and the rest averaged). \item[{\em x}]Abscissas of points to be smoothed in increasing order \item[{\em y}]Values to be smoothed. \item[{\em w}]Weights of data. \item[{\em n}]Number of points to smooth. \item[{\em ys}]Smoothed values. \item[{\em ws}]Smoothed weights \item[{\em yor}]Scratch \item[{\em wor}]Scratch \item[{\em do\-Blank}]replace blanked values with interpolated values. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnSNSmo@{ObitUVSolnSNSmo}}
\index{ObitUVSolnSNSmo@{ObitUVSolnSNSmo}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-SNSmo ({\bf Obit\-Table\-SN} $\ast$ {\em SNTab}, {\bf olong} {\em isuba}, {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a28}


Smooth an SN table and possible interpolate blanked soln. 

Failed solutions are optionally interpolated. Leaves the output table sorted in antenna-time order. If Smo\-Type='VLMB the host {\bf Obit\-UV}{\rm (p.\,\pageref{structObitUV})} of SNTab should have a valid selector and descriptor. All rates are averaged. Routine adapted from the AIPSish UVUTIL.FOR/SLFSMO Table MUST be in Time order when called and will be returned in antenna order Controls on SNTab: \begin{itemize}
\item smo\-Func OBIT\_\-string (4,1,1) smoothing function 'MWF' (median window filter), \char`\"{}GAUS' (Gaussian) else \char`\"{}BOX\char`\"{}, [def \char`\"{}BOX\char`\"{}] \item smo\-Parm OBIT\_\-float (5,1,1) Amplitude smoothing time in hr. [def 0.0] ampl, phase, rate, singleband delay, multiband delay \item smo\-Type OBIT\_\-string (4,1,1) Data to be smoothed 'AMPL', 'PHAS', 'BOTH'[def], 'DELA', 'DERA', 'VLBI','VLMB', 'FULL', ' '='AMPL' \item do\-Blank OBIT\_\-bool (1,1,1) Replace blanked values with interpolated? [def false] \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em SNTab}]SN table object \item[{\em isuba}]Desired subarray, 0=$>$ 1 \item[{\em err}]Error/message stack, returns if error. \end{description}
\end{Desc}
\end{itemize}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnSNSmooth@{ObitUVSolnSNSmooth}}
\index{ObitUVSolnSNSmooth@{ObitUVSolnSNSmooth}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-SNSmooth ({\bf Obit\-Table\-SN} $\ast$ {\em SNTab}, gchar $\ast$ {\em smo\-Func}, gchar $\ast$ {\em smo\-Type}, {\bf ofloat} {\em alpha}, {\bf ofloat} $\ast$ {\em smo\-Parm}, {\bf olong} {\em iif}, {\bf olong} {\em sub}, {\bf ofloat} $\ast$ {\em gncnt}, {\bf ofloat} $\ast$ {\em gnsum}, {\bf olong} {\em nxt}, {\bf ofloat} $\ast$ {\em work1}, {\bf ofloat} $\ast$ {\em work2}, gboolean {\em do\-Blank}, {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a31}


Smooth solutions for a given IF and subarray. 

All poln present are smoothed but only one IF. The KOL pointers are presumed to point at the desired IF. An error is returned if there are any non-zero delays, rates, or multi-band delays. If the reference antenna changes and phase is being smoothed, an error is returned. Multiband delays only smoothed if iif==0; Input table must be in antenna-time order. Routine translated from the AIPSish SNSMOO.FOR/SNSMOO \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em SNTab}]SN table object; must be opened/closed externally \item[{\em smo\-Func}]Smoothing function: 'MWF', 'GAUS', else BOX \item[{\em smo\-Type}]Type of data to smooth 'AMPL', 'PHAS', 'BOTH'[def], 'VLBI','FULL' 'DERA' = Delay \& Rate only \item[{\em alpha}]Alpha clip for MWF (0 -$>$ box, 1 -$>$ pure MWF) \item[{\em smo\-Parm}]Smoothing time in days for: ampl, phase, rate, singleband delay, multiband delay 0=$>$fill in for blanked only. \item[{\em iif}]Desired IF (0-rel) \item[{\em sub}]Desired subarray (1-rel) \item[{\em gncnt}][In/Out] Count for gain normalization \item[{\em gnsum}][In/Out] Sum of gain modulii \item[{\em nxt}]Number of times allowed in WRK \item[{\em work1}]Work buffer (NXT$\ast$16) \item[{\em work2}]Work area $>$= (NXT$\ast$m) (m=2 BOX, 3 GAUS, 4 MWF) \item[{\em do\-Blank}]replace blanked values with interpolated values? \item[{\em err}]Error/message stack, returns if error. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!ObitUVSolnStartUp@{ObitUVSolnStartUp}}
\index{ObitUVSolnStartUp@{ObitUVSolnStartUp}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void Obit\-UVSoln\-Start\-Up ({\bf Obit\-UVSoln} $\ast$ {\em in}, {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a23}


Public: Initialize interpolation. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em in}]Solution Object. \item[{\em err}]Obit\-Error stack. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!smoAmpPh@{smoAmpPh}}
\index{smoAmpPh@{smoAmpPh}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void smo\-Amp\-Ph ({\bf Obit\-Table\-SN} $\ast$ {\em SNTab}, {\bf Obit\-UVSel} $\ast$ {\em sel}, gchar $\ast$ {\em smo\-Func}, gchar $\ast$ {\em smo\-Type}, {\bf ofloat} {\em alpha}, {\bf ofloat} $\ast$ {\em smo\-Parm}, {\bf olong} {\em sub}, {\bf olong} {\em ifbeg}, {\bf olong} {\em ifend}, {\bf odouble} $\ast$ {\em freqs}, gboolean {\em do\-Blank}, {\bf ofloat} $\ast$ {\em gncnt}, {\bf ofloat} $\ast$ {\em gnsum}, {\bf Obit\-Err} $\ast$ {\em err})}\label{ObitUVSoln_8c_a18}


Coherent amplitude/phase smoothing. 

All poln present and the range of IF specified by IFBEG and IFEND are smoothed jointly. The values in a single polarization are averaged after correcting for multiband delay. Any delay and rate smoothing should be done before amplitude and phase smoothing. Any blanked delay and rate values will be set to 0.0. The phases are corrected by the integral of the rate functions from the first time before smoothing. All selected phases in each polarization are averaged and corrected using the integrated phase function for the first IF selected. Routine translated from the AIPSish /export/users/bcotton/Software.dir//AIPS/31DEC02/APL/PGM/NOTST/SNSMO.FOR/SMOAPH Input table must be in antenna-time order. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em SNTab}]SN table object; must be opened/closed externally \item[{\em sel}]pointer to uvdata selector to select data \item[{\em smo\-Func}]Smoothing function: 'MWF', 'GAUS', else BOX \item[{\em smo\-Type}]Type of data to smooth 'AMPL', 'PHAS', 'BOTH'[def] \item[{\em alpha}]Alpha smooth for MWF (0 -$>$ box, 1 -$>$ pure MWF) \item[{\em smo\-Parm}]Smoothing time in days for: ampl, phase 0=$>$fill in for blanked only. \item[{\em sub}]Desired subarray \item[{\em ifbeg}]First IF \item[{\em ifend}]Highest IF \item[{\em freqs}]IF frequency array \item[{\em do\-Blank}]replace blanked values with interpolated values? \item[{\em gncnt}][out] count for gain normalization \item[{\em gnsum}][out] sum of gain modulii \item[{\em err}]Error/message stack, returns if error. \end{description}
\end{Desc}
\index{ObitUVSoln.c@{Obit\-UVSoln.c}!smoIt@{smoIt}}
\index{smoIt@{smoIt}!ObitUVSoln.c@{Obit\-UVSoln.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void smo\-It (gchar $\ast$ {\em smmeth}, {\bf ofloat} {\em width}, {\bf ofloat} {\em alpha}, {\bf ofloat} $\ast$ {\em x}, {\bf ofloat} $\ast$ {\em y}, {\bf ofloat} $\ast$ {\em w}, {\bf olong} {\em n}, {\bf ofloat} $\ast$ {\em ys}, {\bf ofloat} $\ast$ {\em ws}, {\bf ofloat} $\ast$ {\em wrk1}, {\bf ofloat} $\ast$ {\em wrk2}, gboolean {\em do\-Blank})}\label{ObitUVSoln_8c_a19}


Private: Generic smoothing. 

Magic value blanking is supported. Routine adopted from the AIPSish 31DEC02/APL/PGM/NOTST/SNSMO.FOR/SNSMSM \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em smmeth}]Method 'BOX','MWF', 'GAUS', unknown = 'BOX' \item[{\em width}]Smoothing time (days) \item[{\em alpha}]0 -$>$ 1 = pure boxcar -$>$ pure MWF (ALPHA of the data samples are discarded and the rest averaged). \item[{\em x}]Abscissas of points to be smoothed in increasing order \item[{\em y}]Values to be smoothed. \item[{\em w}]Weights of data. \item[{\em n}]Number of points to smooth. \item[{\em ys}][out] Smoothed values. \item[{\em ws}][out] Smoothed weights \item[{\em yor}]Scratch \item[{\em wor}]Scratch \item[{\em do\-Blank}]replace blanked values with interpolated values. \end{description}
\end{Desc}
